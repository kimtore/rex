// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: query.sql

package mixxx

import (
	"context"
	"database/sql"
)

const listCrateTracks = `-- name: ListCrateTracks :many
SELECT tracklist.crate_id, tracklist.track_id, loc.location AS path FROM crate_tracks tracklist
JOIN library ON library.id = tracklist.track_id
JOIN track_locations loc ON library.location = loc.id
WHERE tracklist.crate_id = ?
`

type ListCrateTracksRow struct {
	CrateID int64
	TrackID int64
	Path    sql.NullString
}

func (q *Queries) ListCrateTracks(ctx context.Context, crateID int64) ([]ListCrateTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listCrateTracks, crateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCrateTracksRow{}
	for rows.Next() {
		var i ListCrateTracksRow
		if err := rows.Scan(&i.CrateID, &i.TrackID, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrates = `-- name: ListCrates :many
SELECT id, name, count, show, locked, autodj_source FROM crates
`

func (q *Queries) ListCrates(ctx context.Context) ([]Crate, error) {
	rows, err := q.db.QueryContext(ctx, listCrates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Crate{}
	for rows.Next() {
		var i Crate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Count,
			&i.Show,
			&i.Locked,
			&i.AutodjSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylistTracks = `-- name: ListPlaylistTracks :many
SELECT tracklist.id, tracklist.playlist_id, tracklist.track_id, tracklist.position, tracklist.pl_datetime_added, loc.location AS path FROM PlaylistTracks tracklist
JOIN library ON library.id = tracklist.track_id
JOIN track_locations loc ON library.location = loc.id
WHERE tracklist.playlist_id = ?
ORDER BY tracklist.position
`

type ListPlaylistTracksRow struct {
	ID              int64
	PlaylistID      sql.NullInt64
	TrackID         sql.NullInt64
	Position        sql.NullInt64
	PlDatetimeAdded sql.NullString
	Path            sql.NullString
}

func (q *Queries) ListPlaylistTracks(ctx context.Context, playlistID sql.NullInt64) ([]ListPlaylistTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylistTracks, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlaylistTracksRow{}
	for rows.Next() {
		var i ListPlaylistTracksRow
		if err := rows.Scan(
			&i.ID,
			&i.PlaylistID,
			&i.TrackID,
			&i.Position,
			&i.PlDatetimeAdded,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylists = `-- name: ListPlaylists :many
SELECT id, name, position, hidden, date_created, date_modified, locked FROM Playlists
ORDER BY position
`

func (q *Queries) ListPlaylists(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.Hidden,
			&i.DateCreated,
			&i.DateModified,
			&i.Locked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracks = `-- name: ListTracks :many
SELECT library.id, library.artist, library.title, library.album, library.year, library.genre, library.tracknumber, library.location, library.comment, library.url, library.duration, library.bitrate, library.samplerate, library.bpm, library.wavesummaryhex, library.channels, library.datetime_added, library.mixxx_deleted, library.played, library.header_parsed, library.filetype, library.replaygain, library.timesplayed, library.rating, library."key", library.beats, library.beats_version, library.composer, library.bpm_lock, library.beats_sub_version, library.keys, library.keys_version, library.keys_sub_version, library.key_id, library.grouping, library.album_artist, library.coverart_source, library.coverart_type, library.coverart_location, library.coverart_hash, library.replaygain_peak, library.tracktotal, library.color, tl.location AS path, tl.filesize AS filesize
FROM library
JOIN track_locations tl on library.location = tl.id
ORDER BY library.id
`

type ListTracksRow struct {
	ID               int64
	Artist           sql.NullString
	Title            sql.NullString
	Album            sql.NullString
	Year             sql.NullString
	Genre            sql.NullString
	Tracknumber      sql.NullString
	Location         sql.NullInt64
	Comment          sql.NullString
	Url              sql.NullString
	Duration         sql.NullFloat64
	Bitrate          sql.NullInt64
	Samplerate       sql.NullInt64
	Bpm              sql.NullFloat64
	Wavesummaryhex   []byte
	Channels         sql.NullInt64
	DatetimeAdded    sql.NullString
	MixxxDeleted     sql.NullInt64
	Played           sql.NullInt64
	HeaderParsed     sql.NullInt64
	Filetype         sql.NullString
	Replaygain       sql.NullFloat64
	Timesplayed      sql.NullInt64
	Rating           sql.NullInt64
	Key              sql.NullString
	Beats            []byte
	BeatsVersion     sql.NullString
	Composer         sql.NullString
	BpmLock          sql.NullInt64
	BeatsSubVersion  sql.NullString
	Keys             []byte
	KeysVersion      sql.NullString
	KeysSubVersion   sql.NullString
	KeyID            sql.NullInt64
	Grouping         sql.NullString
	AlbumArtist      sql.NullString
	CoverartSource   sql.NullInt64
	CoverartType     sql.NullInt64
	CoverartLocation sql.NullString
	CoverartHash     sql.NullInt64
	ReplaygainPeak   sql.NullFloat64
	Tracktotal       sql.NullString
	Color            sql.NullInt64
	Path             sql.NullString
	Filesize         sql.NullInt64
}

func (q *Queries) ListTracks(ctx context.Context) ([]ListTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTracksRow{}
	for rows.Next() {
		var i ListTracksRow
		if err := rows.Scan(
			&i.ID,
			&i.Artist,
			&i.Title,
			&i.Album,
			&i.Year,
			&i.Genre,
			&i.Tracknumber,
			&i.Location,
			&i.Comment,
			&i.Url,
			&i.Duration,
			&i.Bitrate,
			&i.Samplerate,
			&i.Bpm,
			&i.Wavesummaryhex,
			&i.Channels,
			&i.DatetimeAdded,
			&i.MixxxDeleted,
			&i.Played,
			&i.HeaderParsed,
			&i.Filetype,
			&i.Replaygain,
			&i.Timesplayed,
			&i.Rating,
			&i.Key,
			&i.Beats,
			&i.BeatsVersion,
			&i.Composer,
			&i.BpmLock,
			&i.BeatsSubVersion,
			&i.Keys,
			&i.KeysVersion,
			&i.KeysSubVersion,
			&i.KeyID,
			&i.Grouping,
			&i.AlbumArtist,
			&i.CoverartSource,
			&i.CoverartType,
			&i.CoverartLocation,
			&i.CoverartHash,
			&i.ReplaygainPeak,
			&i.Tracktotal,
			&i.Color,
			&i.Path,
			&i.Filesize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
