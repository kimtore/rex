// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package mixxx

import (
	"context"
	"database/sql"
)

const listCrateTracks = `-- name: ListCrateTracks :many
SELECT tracklist.crate_id, tracklist.track_id, loc.location AS path FROM crate_tracks tracklist
JOIN library ON library.id = tracklist.track_id
JOIN track_locations loc ON library.location = loc.id
WHERE tracklist.crate_id = ?
`

type ListCrateTracksRow struct {
	CrateID int64
	TrackID int64
	Path    sql.NullString
}

func (q *Queries) ListCrateTracks(ctx context.Context, crateID int64) ([]ListCrateTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listCrateTracks, crateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCrateTracksRow{}
	for rows.Next() {
		var i ListCrateTracksRow
		if err := rows.Scan(&i.CrateID, &i.TrackID, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrates = `-- name: ListCrates :many
SELECT id, name, count, show, locked, autodj_source FROM crates
`

func (q *Queries) ListCrates(ctx context.Context) ([]Crate, error) {
	rows, err := q.db.QueryContext(ctx, listCrates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Crate{}
	for rows.Next() {
		var i Crate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Count,
			&i.Show,
			&i.Locked,
			&i.AutodjSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylistTracks = `-- name: ListPlaylistTracks :many
SELECT tracklist.id, tracklist.playlist_id, tracklist.track_id, tracklist.position, tracklist.pl_datetime_added, loc.location AS path FROM PlaylistTracks tracklist
JOIN library ON library.id = tracklist.track_id
JOIN track_locations loc ON library.location = loc.id
WHERE tracklist.playlist_id = ?
ORDER BY tracklist.position
`

type ListPlaylistTracksRow struct {
	ID              int64
	PlaylistID      sql.NullInt64
	TrackID         sql.NullInt64
	Position        sql.NullInt64
	PlDatetimeAdded sql.NullString
	Path            sql.NullString
}

func (q *Queries) ListPlaylistTracks(ctx context.Context, playlistID sql.NullInt64) ([]ListPlaylistTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylistTracks, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlaylistTracksRow{}
	for rows.Next() {
		var i ListPlaylistTracksRow
		if err := rows.Scan(
			&i.ID,
			&i.PlaylistID,
			&i.TrackID,
			&i.Position,
			&i.PlDatetimeAdded,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylists = `-- name: ListPlaylists :many
SELECT id, name, position, hidden, date_created, date_modified, locked FROM Playlists
ORDER BY position
`

func (q *Queries) ListPlaylists(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.Hidden,
			&i.DateCreated,
			&i.DateModified,
			&i.Locked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracks = `-- name: ListTracks :many
SELECT library.id, library.artist, library.title, library.album, library.year, library.genre, library.tracknumber, library.location, library.comment, library.url, library.duration, library.bitrate, library.samplerate, library.cuepoint, library.bpm, library.wavesummaryhex, library.channels, library.datetime_added, library.mixxx_deleted, library.played, library.header_parsed, library.filetype, library.replaygain, library.timesplayed, library.rating, library."key", library.beats, library.beats_version, library.composer, library.bpm_lock, library.beats_sub_version, library.keys, library.keys_version, library.keys_sub_version, library.key_id, library.grouping, library.album_artist, library.coverart_source, library.coverart_type, library.coverart_location, library.coverart_hash, library.replaygain_peak, library.tracktotal, library.color, library.last_played_at, library.source_synchronized_ms, tl.location AS path, tl.filesize AS filesize
FROM library
JOIN track_locations tl on library.location = tl.id
ORDER BY library.id
`

type ListTracksRow struct {
	ID                   int64
	Artist               sql.NullString
	Title                sql.NullString
	Album                sql.NullString
	Year                 sql.NullString
	Genre                sql.NullString
	Tracknumber          sql.NullString
	Location             sql.NullInt64
	Comment              sql.NullString
	Url                  sql.NullString
	Duration             sql.NullFloat64
	Bitrate              sql.NullInt64
	Samplerate           sql.NullInt64
	Cuepoint             sql.NullInt64
	Bpm                  sql.NullFloat64
	Wavesummaryhex       []byte
	Channels             sql.NullInt64
	DatetimeAdded        sql.NullString
	MixxxDeleted         sql.NullInt64
	Played               sql.NullInt64
	HeaderParsed         sql.NullInt64
	Filetype             sql.NullString
	Replaygain           sql.NullFloat64
	Timesplayed          sql.NullInt64
	Rating               sql.NullInt64
	Key                  sql.NullString
	Beats                []byte
	BeatsVersion         sql.NullString
	Composer             sql.NullString
	BpmLock              sql.NullInt64
	BeatsSubVersion      sql.NullString
	Keys                 []byte
	KeysVersion          sql.NullString
	KeysSubVersion       sql.NullString
	KeyID                sql.NullInt64
	Grouping             sql.NullString
	AlbumArtist          sql.NullString
	CoverartSource       sql.NullInt64
	CoverartType         sql.NullInt64
	CoverartLocation     sql.NullString
	CoverartHash         sql.NullInt64
	ReplaygainPeak       sql.NullFloat64
	Tracktotal           sql.NullString
	Color                sql.NullInt64
	LastPlayedAt         sql.NullTime
	SourceSynchronizedMs sql.NullInt64
	Path                 sql.NullString
	Filesize             sql.NullInt64
}

func (q *Queries) ListTracks(ctx context.Context) ([]ListTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTracksRow{}
	for rows.Next() {
		var i ListTracksRow
		if err := rows.Scan(
			&i.ID,
			&i.Artist,
			&i.Title,
			&i.Album,
			&i.Year,
			&i.Genre,
			&i.Tracknumber,
			&i.Location,
			&i.Comment,
			&i.Url,
			&i.Duration,
			&i.Bitrate,
			&i.Samplerate,
			&i.Cuepoint,
			&i.Bpm,
			&i.Wavesummaryhex,
			&i.Channels,
			&i.DatetimeAdded,
			&i.MixxxDeleted,
			&i.Played,
			&i.HeaderParsed,
			&i.Filetype,
			&i.Replaygain,
			&i.Timesplayed,
			&i.Rating,
			&i.Key,
			&i.Beats,
			&i.BeatsVersion,
			&i.Composer,
			&i.BpmLock,
			&i.BeatsSubVersion,
			&i.Keys,
			&i.KeysVersion,
			&i.KeysSubVersion,
			&i.KeyID,
			&i.Grouping,
			&i.AlbumArtist,
			&i.CoverartSource,
			&i.CoverartType,
			&i.CoverartLocation,
			&i.CoverartHash,
			&i.ReplaygainPeak,
			&i.Tracktotal,
			&i.Color,
			&i.LastPlayedAt,
			&i.SourceSynchronizedMs,
			&i.Path,
			&i.Filesize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
